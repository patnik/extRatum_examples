---
title: "extRatum package example"
author: "Nikos Patias"
date: "12/12/2020"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# This notebook provides an example of `extRatum` package

This is a notebook that demonstrates the use of `extRatum` package, using OpenStreetMap data.
`extRatum` package can be used to summarise the presence of geospatial features in larger geographic areas. It does so by calculating the area covered by a geospatial  feature (i.e. buildings, parks, lakes, etc.). The geospatial features can be of all types of geospatial data (i.e. point, polygons or lines).

In this example, we focus on built environment characteristics.
We make use of OpenStreetMap data and calculate indicators for point, polygon and line data. The reference layer is the Lower Layer Super Output Area (LSOA) boundaries for the city of Liverpool in the United Kingdom.

```{r}
# these are the packages needed
#devtools::install("C:/Users/User/Desktop/extRatum")
library(extRatum)
library(sf)
library(dplyr)
library(tmap)
library(osmdata)
```

## Read Liverpool LSOA boundaries

First, we read in the LSOA boundaries for Liverpool. The data downloaded from CDRC website: https://data.cdrc.ac.uk/

```{r}
# 1. Read in the FUA grids
LSOAs <- st_read("layers/E08000012.shp")

```
Because the area of interest is Liverpool, we should select the British National Grid as a planar coordinate system of reference throughout this notebook.

```{r}
BNG = "epsg:27700"
```


## Point data analysis

In this part of the notebook, we will deal with point data. 

We create a simple query to download point data representing shops in Liverpool.
```{r}
q <- getbb("Liverpool") %>%
  opq() %>%
  add_osm_feature(key = "shop")

shops <- osmdata_sf(q)
```

And plot them.

```{r}
#tmap_mode("view") #use this code for creating an interactive map
tmap_mode("plot")

# show the points and grids
tm_shape(LSOAs) +
  tm_borders() +
  tm_shape(shops$osm_points) +
  tm_dots()
```


Then we calculate the number of points in each polygon using `point_calc()` function. Note that we have to pass a planar coordinate system in all our functions. Here we use British National Grid. 
The output of this function will be a dataframe containing:

- the LSOA code;
- the total area in sqkm of each LSOA;
- the number of points (i.e. shops) in each LSOA; and
- the ratio of points to the total LSOA area (or in other words the number of points by sqkm). In this way, we have a relative measure that can be compared across all LSOAs and is independent of their size.

Note that we have used the argument `total_points = TRUE` which returns the total number of points without differentiating between different shop types.

```{r}

Shops_total <- point_calc(
  point_data = shops$osm_points,
  higher_geo_lay = LSOAs,
  unique_id_code = 'lsoa11cd',
  crs = BNG,
  total_points = TRUE
  )

# inspect the results
head(Shops_total)


```

In some cases though we want to know the split between different types of points. In this case, we change the `total_points = FALSE` and specify the column name that includes the classification (see `class_col`).

```{r}

Shops_class <- point_calc(
  point_data = shops$osm_points,
  higher_geo_lay = LSOAs,
  unique_id_code = 'lsoa11cd',
  class_col = 'shop',
  crs = BNG,
  total_points = FALSE
  )



```

The output of this function will be a list of three dataframes.

1. A dataframe in long format reporting: 

- the LSOA code;
- the total area in sqkm of each LSOA;
- the classification of the points within each LSOA;
- the number of points in each class (i.e. bakery, beauty) in each LSOA; and
- the ratio of points in each class to the total LSOA area (or in other words the number of points by sqkm).


```{r}
head(Shops_class$PointsLong)

```

2. A dataframe in wide format reporting: 

- the LSOA code;
- the number of points in each class (i.e. bakery, beauty) in each LSOA.

```{r}
head(Shops_class$PointsCountWide)

```

3. A dataframe in wide format reporting: 

- the LSOA code;
- the ratio of points in each class to the total LSOA area (or in other words the number of points by sqkm).

```{r}
head(Shops_class$PointsRatioWide)

```

Finally we can plot the results in a map, which shows the density of shops in the city of Liverpool at the LSOA level. 
```{r}
# attach the information calculate using extRatum to the LSOA boundaries
Liv_shops_geo <- dplyr::left_join(LSOAs, Shops_total, by = "lsoa11cd")

tm_shape(Liv_shops_geo) +
  tm_fill("NoPoints", style = "fisher", palette = "Reds", alpha = 0.6)
```


## Polygon data analysis
In this part, we will deal with polygon data.

We create a query to download building footprints for the city of Liverpool using OpenStreetMap data.
```{r}
q2 <- getbb("Liverpool", limit = 100) %>%
  opq() %>%
  add_osm_feature(key = "building")

buildings <- osmdata_sf(q2)

```

We can then subset the buildings that are classified as retail. 

```{r}
retail_buildings <- subset(buildings$osm_polygons, building=="retail")

```



Then, we run the function that calculates the area in sqm covered by retail buildings in each LSOA using `areal_calc()` function.
```{r}
Liv_retail <- areal_calc(
  polygon_layer = retail_buildings,
  higher_geo_lay = LSOAs,
  unique_id_code = 'lsoa11cd',
  crs = BNG
  )

```

The output of this function will be a dataframe containing:

- the LSOA code;
- the total area in sqkm of each LSOA;
- the area covered by the geospatial feature we have selected in each LSOA; and
- the ratio of geospatial feature area to the total LSOA area (or in other words the area covered by the geospatial feature by sqkm).

Given that everything is measured in sqkm, the ratio represents what is the % of area covered by retail buildings by sqkm. In this way, we have a relative measure that can be compared across all LSOAs and is independent of their size.

```{r}
head(Liv_retail)
```


Finally, we can plot the results, showing the total area covered by retail buildings in each LSOA in Liverpool.
Note that OSM data on retail buildings are not complete for the city of Liverpool. Thus, we see too many LSOAs missing data. 

```{r}
Liv_retail_geo <- dplyr::left_join(LSOAs, Liv_retail, by = "lsoa11cd")

tm_shape(Liv_retail_geo) +
  tm_fill("AreaCovered", style = "fisher", palette = "Reds", alpha = 0.6) 
```


## Line data analysis
In this part, we will deal with line data.

We create a query to download highway lines for the city of Liverpool using OpenStreetMap data.

```{r}
q3 <- getbb("Liverpool") %>%
  opq() %>%
  add_osm_feature(key = "highway")

highways <- osmdata_sf(q3)
```

We can then create subsets of the dataset such as pathways for pedestrian use.

```{r}
pedestrian <- subset(highways$osm_lines, highway == "pedestrian")
```

Then we can calculate the total length of pedestrian pathways routes by LSOA using `line_calc()` function.

```{r}
Liv_footways <- line_calc(
  line_layer = pedestrian,
  higher_geo_lay = LSOAs,
  unique_id_code = 'lsoa11cd',
  crs = BNG
  )


```

The output of this function will be a dataframe containing:

- the LSOA code;
- the total area in sqkm of each LSOA;
- the total line length by the geospatial feature we have selected in each LSOA; and
- the ratio of geospatial feature length to the total LSOA area (or in other words the length of the geospatial feature by sqkm). In this way, we have a relative measure that can be compared across all LSOAs and is independent of their size.

```{r}
head(Liv_footways)
```


Finally, we can plot the results, showing the total length of pedestrian pathways in each LSOA in Liverpool.
Note that the majority is around Liverpool city centre where we see darker colours. 

```{r}
Liv_footways_geo <- left_join(LSOAs, Liv_footways, by = "lsoa11cd")


tm_shape(Liv_footways_geo) +
  tm_fill("TotalLength", style = "fisher", palette = "Reds", alpha = 0.6)
```



```{r}

```




